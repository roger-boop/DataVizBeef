---
title: "home-assignment"
author: "authors"
date: "2022-11-16"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Q1

An easy way to load the data is with `read.table()`

```{r q1-loads}
#P3 <- read.table('P3.tsv', header = TRUE)
#P4 <- read.table('P4.tsv', header = TRUE)
#P5 <- read.table('P5.tsv', header = TRUE)
```

The method used above requires us to uncompress the data, which might not be a good idea when working with large files, that is why we will use the gfile() function to avoid this problem.

```{r q1-loads-alt}
P3_2 <- read.table(gzfile("P3.tsv.gz"), header = TRUE)
P4_2 <- read.table(gzfile("P4.tsv.gz"), header = TRUE)
P5_2 <- read.table(gzfile("P5.tsv.gz"), header = TRUE)
```

Another way of loading the data is to use read_tsv, a function specialized in loading tsv files into R.

```{r q1-loads-alt2}
library(readr)
P3_3 <- read_tsv(gzfile("P3.tsv.gz"), col_names = TRUE)
P4_3 <- read_tsv(gzfile("P4.tsv.gz"), col_names = TRUE)
P5_3 <- read_tsv(gzfile("P5.tsv.gz"), col_names = TRUE)
```

We could also treat our data like a csv file and load it into R using read_csv. In this case we must specify that each column is separated by a tab in order to prevent the function of returning a table with just one column.

```{r}
P3_4 <- read.csv(gzfile("P3.tsv.gz"), header = TRUE, sep = "\t")
P4_4 <- read.csv(gzfile("P4.tsv.gz"), header = TRUE, sep = "\t")
P5_4 <- read.csv(gzfile("P5.tsv.gz"), header = TRUE, sep = "\t")
```

Finally we can take advantage of the fact that tsv files are delimited text files to load our data using read.delim.

```{r}
P3_5 <- read.delim(gzfile("P3.tsv.gz"), header = TRUE)
P4_5 <- read.delim(gzfile("P4.tsv.gz"), header = TRUE)
P5_5 <- read.delim(gzfile("P5.tsv.gz"), header = TRUE)
```

We can show the data is loaded by performing `head()` on them, which will print out the first few lines of the dataframe.

```{r q1-evidence}
#Data loaded with read.table
head(P3)
head(P4)
head(P5)
#Data loaded with read_tsv
head(P3_3)
head(P4_3)
head(P5_3)
#Data loaded with read.csv
head(P3_4)
head(P4_4)
head(P5_4)
#Data loaded with read.delim
head(P3_5)
head(P4_5)
head(P5_5)
```

Having the samples as rownames and the genes as column names will make our data more intuitive to work with, that is why we will transpose our tables.

```{r q1-transpose_matrix}
rownames(P3) <- P3$gene
P3$gene <- NULL
rownames(P4) <- P4$gene
P4$gene <- NULL
rownames(P5) <- P5$gene
P5$gene <- NULL

P3 <- t(P3)
P4 <- t(P4)
P5 <- t(P5)
```


NOTA: Esto no hace falta. He puesto los replicates en el dataframe de treatment. borrar?


## Q2

We can use the `read.table()` command again. Let's also split the *label* column in *celltypes* and *conditions*.

```{r q2-packages, message=FALSE}
library(dplyr)
library(tidyr)
```

```{r q2-load}
treatments <- read.table('samplesheet.tsv', header = TRUE)

treatments <- treatments %>% separate(col = label, into = c("celltypes", "conditions"), sep = "\\+")
```

Now, let's check the number of conditions. 

```{r q2-cond}
table(treatments$conditions)
```

We can also see the amount of cell types in each condition.

```{r q2-cellconds}
table(treatments$conditions, treatments$celltypes)
```

In order to determine whether or not we have to record cell names we will check if the indexes for each cell match in the tsv files and in treatments. If they do then we can remove them since we will already know which cell each column is referring to by binding the data with the tsv files, otherwise we will have to record it.

```{r q3-record_cell_or_not}
treatments$cellnames == cbind(rownames(P3), rownames(P4), rownames(P5))
treatments$replicates <- append(append(rep("P3", 96), rep("P4",96)), rep("P5", 96))
```

We can see the index of the cells is the same in both treatments and the tsv files, therefore we don't have to record those names.

To end this exercise we will create a data frame with all the information obtained till now.

```{r final_data}
X <- rbind(P3, P4, P5)
X_def <- data.frame(X,  treatments[,2:ncol(treatments)])
```

## Q3

```{r scaling}
#first, remove columns with all zeroes
X_nozero <- X[, colSums(X)>0]
#next, normalize the dataframe by dividing each value
#by the sum of its row
Y = X_nozero/rowSums(X_nozero)
```

```{r first-pca}
pca <- stats::prcomp(X)
pca_normalized <- stats::prcomp(Y, scale = TRUE)
```

```{r libraries}
library(ggplot2)
library(Rtsne)
```

```{r pca-plot-no-normalized}
components <- as_tibble(pca$x) %>% bind_cols(treatments) %>% as.data.frame()
ggplot(components, aes(x = PC1, y = PC2, color = replicates)) + geom_point() + theme_light() + labs(color = "Replicate", title = "PCA non-normalized")
```

There is a clear batch effect, mostly among the P3 replicate, as they are mostly clustered away from the P4 and P5 clusters.

```{r pca-plot-normalized}
components <- as_tibble(pca_normalized$x) %>% bind_cols(treatments) %>% as.data.frame()
ggplot(components, aes(x = PC1, y = PC2, color = replicates)) + geom_point() + theme_light() + labs(color = "Replicates", title = "PCA normalized")
```

This might have solved the batch effect, but there is 1 huge outlier along the PC1 in our data. Let's remove it.

```{r remove-outlier}
#identify the outlier
my.tibble <- as_tibble(pca_normalized$x)
#we see in the output there is a huge outlier, so let's remove it
my.tibble$PC1
#this outlier is in position 220, remove it from the pca and the treatments
my.tibble <- my.tibble[my.tibble$PC1>(-400),]
treatments_no_outlier <- treatments[-220,]
```

```{r pca-normalized-no-outlier}
components <- my.tibble %>% bind_cols(treatments_no_outlier) %>% as.data.frame()
ggplot(components, aes(x = PC1, y = PC2, color = replicates)) + geom_point() + theme_light() + labs(color = "Replicates", title = "PCA normalized")
```

The outlier is gone, and we can clearly differentiate the clusters. The batch effect is also clearly gone compared to the non-scaled, non-normalized PCA. Let's do some tSNEs.

```{r tsnes}
X_tsne <- Rtsne(X)
Y_tsne <- Rtsne(Y)
```

```{r tsne-non-normalized}
tsne_plot <- data.frame(x = X_tsne$Y[,1], 
                        y = X_tsne$Y[,2], 
                        col = treatments$replicates,
                        sha = treatments$conditions,
                        alp = treatments$celltypes)
ggplot(tsne_plot) + geom_point(aes(x=x, y=y, color=col)) + theme_light() + labs(color = "Replicates", title = "tSNE non-normalized")
```

There is some clear batch effect once again. Let's remove it by plotting the normalized data.

```{r tsne-normalized}
tsne_plot <- data.frame(x = Y_tsne$Y[,1], 
                        y = Y_tsne$Y[,2], 
                        col = treatments$replicates,
                        sha = treatments$conditions,
                        alp = treatments$celltypes)
ggplot(tsne_plot) + geom_point(aes(x=x, y=y, color=col)) + theme_light() + labs(color = "Replicates", title = "tSNE normalized") 
```

## Q4

Let's try to change the perplexity parameter and see how it affects the data.

```{r perplex}
for (i in c(3, 60, 70))
{
  i_tsne <- Rtsne(Y, perplexity = i)
  tsne_plot <- data.frame(x = i_tsne$Y[,1], 
                        y = i_tsne$Y[,2], 
                        col = treatments$replicates,
                        sha = treatments$conditions,
                        alp = treatments$celltypes)
  print(ggplot(tsne_plot) + geom_point(aes(x=x, y=y, color=col)) + theme_light() + labs(color = "Replicates", title = paste0("tSNE for perplexity = ", i)))
}
```

The perplexity changes the number of neightbors that each cluster should have. For perplexity = 3, the clusters only have 3 neighbors, so the clusters are tiny. It's good to have a high perplexity, as high as possible. 


Let's try changing the iterations now.

```{r iter}
for (i in c(5, 500, 2000))
{
  i_tsne <- Rtsne(Y, max_iter = i)
  tsne_plot <- data.frame(x = i_tsne$Y[,1], 
                        y = i_tsne$Y[,2], 
                        col = treatments$replicates,
                        sha = treatments$conditions,
                        alp = treatments$celltypes)
  print(ggplot(tsne_plot) + geom_point(aes(x=x, y=y, color=col)) + theme_light() + labs(color = "Replicates", title = paste0("tSNE for iterations = ", i)))
}
```

A lower number of iterations leads to one singular big cluster. The more iterations, the more distinct the clusters are. A higher number is better in this case.


## Q5

In order to fetermine whether or not SAHA and PMA have the same effect on the cells we will perform a pca and see how close the clusters of each condition are. 

```{r}
Y_SAHA_PMA <- Y[((treatments$conditions == "SAHA") == TRUE) | ((treatments$conditions == "PMA")== TRUE),]

treatments$totalExpr <- rowSums(X)

treat_SAHA_PMA <- treatments[(treatments$conditions == "SAHA") | (treatments$conditions == "PMA"),]



PCA_filtered <- stats::prcomp(Y_SAHA_PMA, scale = TRUE)
library(ggfortify)
components_filtered <- components[(components$conditions == "SAHA") | (components$conditions == "PMA"),]

ggplot(components_filtered, aes(x = PC1, y = PC2, color = conditions)) + geom_point() + theme_light() + labs(color = "Conditions")

```

In the plot above we can see that PMA and SAHA do not have the same effect on cells since they do not share a cluster.

## Q6

```{r}
components$totalExpr <- rowSums(components[,1:288])

pl <- ggplot(components, aes(x = PC1, y = PC2, size = totalExpr, shape = replicates, color = conditions)) + geom_point() + theme_light() + labs(color = "Conditions") #+ geom_text(label = rownames(components), colour = "black")
pl
```
PC2 seems to separate cells based on their conditions while PC1 based on their total expression. 

## Q7

In order to find three genes that are activated by SAHA but not by PMA we will add labels to the graph above and look for a cell which is only activated by SAHA.

```{r}
treatments_no_outlier[248,]$cellnames
treatments_no_outlier[248,]$conditions
```
Cell P2771_N710.S502 is only activated by SAHA, let's see which genes this cell posseses.

```{r}
#I obtain all genes in P2771_N710.S502 cell.
Y_filtered <- Y[,Y["P2771_N710.S502",] != 0]

colnames(Y)
```


